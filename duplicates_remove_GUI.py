#!/usr/bin/env python3
"""
Duplicate Row Remover with GUI
Removes duplicate rows from CSV files based on 'is_duplicate' column and shows removed data.
Works with files generated by the Duplicate Detector.
"""

import os
import threading
import tkinter as tk
from pathlib import Path
from tkinter import filedialog, messagebox, scrolledtext, ttk

import pandas as pd


class DuplicateRemoverGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Duplicate Row Remover")
        self.root.geometry("900x700")
        self.root.minsize(800, 600)

        # Variables
        self.input_files = []
        self.output_directory = tk.StringVar()
        self.removal_stats = {}

        self.create_widgets()

    def create_widgets(self):
        # Main frame
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

        # Configure grid weights
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)

        # Title
        title_label = ttk.Label(
            main_frame, text="Duplicate Row Remover", font=("Arial", 16, "bold")
        )
        title_label.grid(row=0, column=0, columnspan=3, pady=(0, 10))

        # Description
        desc_label = ttk.Label(
            main_frame,
            text="Remove duplicate rows from CSV files with 'is_duplicate' column",
            font=("Arial", 10),
            foreground="gray",
        )
        desc_label.grid(row=1, column=0, columnspan=3, pady=(0, 20))

        # Input Files Section
        ttk.Label(
            main_frame,
            text="Input Files (with is_duplicate column):",
            font=("Arial", 12, "bold"),
        ).grid(row=2, column=0, sticky=tk.W, pady=(0, 5))

        # Files listbox with scrollbar
        files_frame = ttk.Frame(main_frame)
        files_frame.grid(
            row=3, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 10)
        )
        files_frame.columnconfigure(0, weight=1)

        self.files_listbox = tk.Listbox(files_frame, height=6, selectmode=tk.EXTENDED)
        files_scrollbar = ttk.Scrollbar(
            files_frame, orient=tk.VERTICAL, command=self.files_listbox.yview
        )
        self.files_listbox.configure(yscrollcommand=files_scrollbar.set)

        self.files_listbox.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        files_scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))

        # File buttons
        file_buttons_frame = ttk.Frame(main_frame)
        file_buttons_frame.grid(row=4, column=0, columnspan=3, pady=(0, 15))

        ttk.Button(file_buttons_frame, text="Add Files", command=self.add_files).pack(
            side=tk.LEFT, padx=(0, 5)
        )
        ttk.Button(
            file_buttons_frame, text="Add Directory", command=self.add_directory
        ).pack(side=tk.LEFT, padx=5)
        ttk.Button(
            file_buttons_frame, text="Remove Selected", command=self.remove_selected
        ).pack(side=tk.LEFT, padx=5)
        ttk.Button(file_buttons_frame, text="Clear All", command=self.clear_all).pack(
            side=tk.LEFT, padx=(5, 0)
        )

        # Options Frame
        options_frame = ttk.LabelFrame(main_frame, text="Removal Options", padding="10")
        options_frame.grid(
            row=5, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 15)
        )

        self.keep_original = tk.BooleanVar(value=True)
        ttk.Checkbutton(
            options_frame,
            text="Keep original files (create new cleaned files)",
            variable=self.keep_original,
        ).grid(row=0, column=0, sticky=tk.W)

        self.show_removed_data = tk.BooleanVar(value=True)
        ttk.Checkbutton(
            options_frame,
            text="Show detailed removed data in log",
            variable=self.show_removed_data,
        ).grid(row=1, column=0, sticky=tk.W)

        # Output Directory Section
        ttk.Label(
            main_frame, text="Output Directory:", font=("Arial", 12, "bold")
        ).grid(row=6, column=0, sticky=tk.W, pady=(5, 5))

        output_frame = ttk.Frame(main_frame)
        output_frame.grid(
            row=7, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 15)
        )
        output_frame.columnconfigure(0, weight=1)

        self.output_entry = ttk.Entry(
            output_frame, textvariable=self.output_directory, width=50
        )
        self.output_entry.grid(row=0, column=0, sticky=(tk.W, tk.E), padx=(0, 5))

        ttk.Button(
            output_frame, text="Browse", command=self.browse_output_directory
        ).grid(row=0, column=1)

        # Process Button
        self.process_button = ttk.Button(
            main_frame,
            text="Remove Duplicates",
            command=self.start_processing,
            style="Accent.TButton",
        )
        self.process_button.grid(row=8, column=0, columnspan=3, pady=(0, 15))

        # Progress Bar
        self.progress = ttk.Progressbar(main_frame, mode="determinate")
        self.progress.grid(
            row=9, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 10)
        )

        # Status/Log Area
        ttk.Label(
            main_frame,
            text="Processing Log & Removed Data:",
            font=("Arial", 12, "bold"),
        ).grid(row=10, column=0, sticky=tk.W, pady=(10, 5))

        self.log_text = scrolledtext.ScrolledText(main_frame, height=15, width=80)
        self.log_text.grid(
            row=11,
            column=0,
            columnspan=3,
            sticky=(tk.W, tk.E, tk.N, tk.S),
            pady=(0, 10),
        )

        # Configure grid weights for resizing
        main_frame.rowconfigure(11, weight=1)

    def add_files(self):
        """Add CSV files to the processing list."""
        files = filedialog.askopenfilenames(
            title="Select Files with 'is_duplicate' column",
            filetypes=[
                ("Supported files", "*.csv *.xlsx *.xls"),
                ("CSV files", "*.csv"),
                ("Excel files", "*.xlsx *.xls"),
                ("All files", "*.*"),
            ],
        )

        for file in files:
            if file not in self.input_files:
                # Validate file has is_duplicate column
                if self.validate_file(file):
                    self.input_files.append(file)
                    self.files_listbox.insert(tk.END, os.path.basename(file))
                else:
                    messagebox.showwarning(
                        "Invalid File",
                        f"File '{os.path.basename(file)}' does not contain 'is_duplicate' column.",
                    )

        self.log(
            f"Added {len([f for f in files if self.validate_file(f)])} valid file(s)"
        )

    def validate_file(self, file_path):
        """Validate that the file has the required 'is_duplicate' column."""
        try:
            file_path = Path(file_path)
            if file_path.suffix.lower() == ".csv":
                df = pd.read_csv(
                    file_path, nrows=1
                )  # Read only first row to check columns
            elif file_path.suffix.lower() in [".xlsx", ".xls"]:
                df = pd.read_excel(
                    file_path, nrows=1
                )  # Read only first row to check columns
            else:
                return False
            return "is_duplicate" in df.columns
        except Exception:
            return False

    def add_directory(self):
        """Add all valid files from a directory."""
        directory = filedialog.askdirectory(title="Select Directory")
        if not directory:
            return

        files_added = 0
        supported_extensions = [".csv", ".xlsx", ".xls"]

        for file_path in Path(directory).iterdir():
            if file_path.suffix.lower() in supported_extensions:
                full_path = str(file_path)
                if full_path not in self.input_files and self.validate_file(full_path):
                    self.input_files.append(full_path)
                    self.files_listbox.insert(tk.END, file_path.name)
                    files_added += 1

        self.log(f"Added {files_added} valid file(s) from directory: {directory}")

    def remove_selected(self):
        """Remove selected files from the list."""
        selected_indices = self.files_listbox.curselection()
        if not selected_indices:
            messagebox.showwarning("Warning", "Please select files to remove.")
            return

        # Remove in reverse order to maintain indices
        for index in reversed(selected_indices):
            self.files_listbox.delete(index)
            del self.input_files[index]

        self.log(f"Removed {len(selected_indices)} file(s)")

    def clear_all(self):
        """Clear all files from the list."""
        self.files_listbox.delete(0, tk.END)
        self.input_files.clear()
        self.log("Cleared all files")

    def browse_output_directory(self):
        """Browse for output directory."""
        directory = filedialog.askdirectory(title="Select Output Directory")
        if directory:
            self.output_directory.set(directory)

    def log(self, message):
        """Add message to the log."""
        self.log_text.insert(tk.END, f"{message}\n")
        self.log_text.see(tk.END)
        self.root.update_idletasks()

    def validate_inputs(self):
        """Validate user inputs before processing."""
        if not self.input_files:
            messagebox.showerror(
                "Error", "Please select at least one CSV file to process."
            )
            return False

        if not self.output_directory.get():
            messagebox.showerror("Error", "Please select an output directory.")
            return False

        if not os.path.exists(self.output_directory.get()):
            messagebox.showerror("Error", "Output directory does not exist.")
            return False

        return True

    def display_removed_data(self, filename, removed_df):
        """Display detailed information about removed duplicate rows."""
        if removed_df.empty:
            self.log(f"  No duplicate rows found in {filename}")
            return

        self.log(f"  Removed {len(removed_df)} duplicate rows from {filename}:")
        self.log("  " + "-" * 60)

        # Show column headers
        columns = [col for col in removed_df.columns if col != "is_duplicate"]
        header = "  | ".join(
            [f"{col[:15]:15}" for col in columns[:5]]
        )  # Show first 5 columns
        self.log(f"  {header}")
        self.log("  " + "-" * len(header))

        # Show removed rows (limit to first 20 rows to avoid overwhelming the log)
        display_limit = min(20, len(removed_df))
        for idx, (_, row) in enumerate(removed_df.head(display_limit).iterrows()):
            row_data = []
            for col in columns[:5]:  # Show first 5 columns
                value = str(row[col])[:15]  # Truncate long values
                row_data.append(f"{value:15}")

            row_str = "  | ".join(row_data)
            self.log(f"  {row_str}")

        if len(removed_df) > display_limit:
            self.log(f"  ... and {len(removed_df) - display_limit} more rows")

        self.log("  " + "-" * 60)

    def process_single_file(self, file_path, file_index, total_files):
        """Process a single file to remove duplicates."""
        try:
            file_path = Path(file_path)
            self.log(f"Processing ({file_index + 1}/{total_files}): {file_path.name}")

            # Read the file based on its extension
            if file_path.suffix.lower() == ".csv":
                df = pd.read_csv(file_path)
            elif file_path.suffix.lower() in [".xlsx", ".xls"]:
                df = pd.read_excel(file_path)
            else:
                self.log(f"Error: Unsupported file format: {file_path.suffix}")
                return

            # Validate is_duplicate column exists
            if "is_duplicate" not in df.columns:
                self.log(f"Error: 'is_duplicate' column not found in {file_path.name}")
                return

            original_count = len(df)

            # Separate duplicate and non-duplicate rows
            duplicate_rows = df[df["is_duplicate"]]
            # Clean data by removing duplicates
            clean_df = df[~df["is_duplicate"]].copy()

            # Remove the is_duplicate column from clean data
            if "is_duplicate" in clean_df.columns:
                clean_df = clean_df.drop("is_duplicate", axis=1)

            removed_count = len(duplicate_rows)
            remaining_count = len(clean_df)

            # Store statistics
            self.removal_stats[file_path.name] = {
                "original": original_count,
                "removed": removed_count,
                "remaining": remaining_count,
            }

            # Create output filename
            if self.keep_original.get():
                output_filename = f"{file_path.stem}_cleaned.csv"
            else:
                output_filename = file_path.name

            output_path = Path(self.output_directory.get()) / output_filename

            # Save cleaned data
            clean_df.to_csv(output_path, index=False)

            # Log results
            self.log(f"  Original rows: {original_count}")
            self.log(f"  Removed duplicates: {removed_count}")
            self.log(f"  Remaining rows: {remaining_count}")
            self.log(f"  Saved as: {output_filename}")

            # Show removed data if requested
            if self.show_removed_data.get() and not duplicate_rows.empty:
                self.display_removed_data(file_path.name, duplicate_rows)

            self.log("-" * 70)

        except Exception as e:
            self.log(f"Error processing {file_path.name}: {str(e)}")

    def process_files(self):
        """Process all selected files to remove duplicates."""
        try:
            self.removal_stats.clear()
            total_files = len(self.input_files)

            self.log("Starting duplicate removal process...")
            self.log(f"Processing {total_files} file(s)")
            self.log("=" * 70)

            # Set progress bar to determinate mode
            self.progress.config(mode="determinate", maximum=total_files)

            for i, file_path in enumerate(self.input_files):
                self.process_single_file(file_path, i, total_files)

                # Update progress bar
                self.progress["value"] = i + 1
                self.root.update_idletasks()

            # Generate summary report
            self.generate_summary_report()

            messagebox.showinfo(
                "Success",
                f"Duplicate removal completed!\n\n"
                f"Processed {total_files} file(s)\n"
                f"Output saved to: {self.output_directory.get()}\n\n"
                f"Check the log for detailed information about removed duplicates.",
            )

        except Exception as e:
            error_msg = f"An error occurred during processing: {str(e)}"
            self.log(error_msg)
            messagebox.showerror("Error", error_msg)

        finally:
            # Re-enable the process button and reset progress bar
            self.process_button.config(state=tk.NORMAL)
            self.progress["value"] = 0

    def generate_summary_report(self):
        """Generate a summary report of the removal process."""
        self.log("=" * 70)
        self.log("DUPLICATE REMOVAL SUMMARY REPORT")
        self.log("=" * 70)

        total_original = sum(stats["original"] for stats in self.removal_stats.values())
        total_removed = sum(stats["removed"] for stats in self.removal_stats.values())
        total_remaining = sum(
            stats["remaining"] for stats in self.removal_stats.values()
        )

        self.log(f"Files processed: {len(self.removal_stats)}")
        self.log(f"Total original rows: {total_original:,}")
        self.log(f"Total removed duplicates: {total_removed:,}")
        self.log(f"Total remaining rows: {total_remaining:,}")

        if total_original > 0:
            removal_percentage = (total_removed / total_original) * 100
            self.log(f"Percentage of data removed: {removal_percentage:.2f}%")

        self.log("\nPer-file breakdown:")
        self.log("-" * 70)

        for filename, stats in self.removal_stats.items():
            percentage = (
                (stats["removed"] / stats["original"] * 100)
                if stats["original"] > 0
                else 0
            )
            self.log(f"{filename}:")
            self.log(
                f"  Original: {stats['original']:,} | Removed: {stats['removed']:,} | "
                f"Remaining: {stats['remaining']:,} | Removed: {percentage:.1f}%"
            )

        self.log("=" * 70)
        self.log(f"All cleaned files saved to: {self.output_directory.get()}")

    def start_processing(self):
        """Start the duplicate removal process in a separate thread."""
        if not self.validate_inputs():
            return

        # Disable the process button
        self.process_button.config(state=tk.DISABLED)

        # Clear previous logs
        self.log_text.delete(1.0, tk.END)

        # Start processing in a separate thread to keep GUI responsive
        processing_thread = threading.Thread(target=self.process_files)
        processing_thread.daemon = True
        processing_thread.start()


def main():
    """Main function to run the Duplicate Remover GUI application."""
    root = tk.Tk()

    # Set style
    style = ttk.Style()
    if "clam" in style.theme_names():
        style.theme_use("clam")

    DuplicateRemoverGUI(root)
    root.mainloop()


if __name__ == "__main__":
    main()
